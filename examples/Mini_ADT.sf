sig ValueAlg[V] where
  intV : Int -> V,
  boolV : Bool -> V;
algebra evalValue implements ValueAlg[{value : {toInt : Int, toBool : Bool}}] where
  value@(intV x)  = { toInt = x, toBool = True },
  value@(boolV x) = { toInt = 0, toBool = x    };
algebra checkInt implements ValueAlg[{is_Int : Bool}] where
  is_Int@(intV x)  = True,
  is_Int@(boolV x) = False;
algebra checkBool implements ValueAlg[{is_Bool : Bool}] where
  is_Bool@(intV x)  = False,
  is_Bool@(boolV x) = True;
fdata Value from ValueAlg[V].V;
let isInt (x : Value)    = (x.accept[{is_Int : Bool}] checkInt).is_Int;
let isBool (x : Value)   = (x.accept[{is_Bool : Bool}] checkBool).is_Bool;
let getInt (x : Value)   = (x.accept[{value : {toInt : Int, toBool : Bool}}] evalValue).value.toInt;
let getBool (x : Value)  = (x.accept[{value : {toInt : Int, toBool : Bool}}] evalValue).value.toBool;
let sameTypeV (x : Value) (y : Value) = (isInt x && isInt y) || (isBool x && isBool y);

sig MaybeAlg[M] where
  just : Value -> M,
  nothing : M;
algebra evalJust implements MaybeAlg[{value : Value}] where
  value@(just x)  = x,
  value@(nothing) = intV 0;
algebra checkJust implements MaybeAlg[{is_Just : Bool}] where
  is_Just@(just x)  = True,
  is_Just@(nothing) = False;
fdata Maybe from MaybeAlg[M].M;
let isJust (x : Maybe)   = (x.accept[{is_Just : Bool}] checkJust).is_Just;
let fromJust (x : Maybe) = (x.accept[{value : Value}] evalJust).value;
let sameTypeM (x : Maybe) (y : Maybe) = if isJust x && isJust y then sameTypeV (fromJust x) (fromJust y) else False;
let showMaybe (x : Maybe) = if isJust x then let x1 = fromJust x;
                                if isInt x1 then "\{getInt x1}" else if isBool x1 then "\{getBool x1}" else "nothing"
                            else "nothing";

sig TTypeAlg[T] where
  tInt : T, tBool : T, tNot : T;
algebra checkTNum implements TTypeAlg[{value : Int}] where
  value@(tInt) = 1,
  value@(tBool) = 2,
  value@(tNot) = 3;
fdata TType from TTypeAlg[T].T;
let getTNum (x : TType) = (x.accept[{value : Int}] checkTNum).value;
let isTInt (x : TType) = getTNum x == 1;
let isTBool (x : TType) = getTNum x == 2;
let isTNot (x : TType) = getTNum x == 3;
let sameTypeT (x : TType) (y : TType) = getTNum x == getTNum y && getTNum x != 3;
let showTType (x : TType) = if isTInt x then "TInt" else if isTBool x then "TBool" else "TNot";

sig BinaryOpAlg[B] where
  add : B, sub : B, or : B, gt : B, eq : B;
algebra evalBinary implements BinaryOpAlg[{func : Maybe -> Maybe -> Maybe}] where
  func@(add) = \(x : Maybe) -> \(y : Maybe) ->
               if isJust x && isJust y then let x1 = fromJust x; let y1 = fromJust y;
                   if isInt x1 && isInt y1 then just (intV (getInt x1 + getInt y1)) else nothing
               else nothing,
  func@(sub) = \(x : Maybe) -> \(y : Maybe) ->
               if isJust x && isJust y then let x1 = fromJust x; let y1 = fromJust y;
                   if isInt x1 && isInt y1 then just (intV (getInt x1 - getInt y1)) else nothing
               else nothing,
  func@(or)  = \(x : Maybe) -> \(y : Maybe) ->
               if isJust x && isJust y then let x1 = fromJust x; let y1 = fromJust y;
                   if isBool x1 && isBool y1 then just (boolV (getBool x1 || getBool y1)) else nothing
               else nothing,
  func@(gt)  = \(x : Maybe) -> \(y : Maybe) ->
               if isJust x && isJust y then let x1 = fromJust x; let y1 = fromJust y;
                   if isInt x1 && isInt y1 then just (boolV (getInt x1 > getInt y1)) else nothing
               else nothing,
  func@(eq)  = \(x : Maybe) -> \(y : Maybe) ->
               if isJust x && isJust y then let x1 = fromJust x; let y1 = fromJust y;
                   if isInt x1 && isInt y1 then just (boolV (getInt x1 == getInt y1)) else nothing
               else nothing;
algebra tcheckBinary implements BinaryOpAlg[{func : TType -> TType -> TType}] where
  func@(add) = \(x : TType) -> \(y : TType) -> if isTInt x && isTInt y then tInt else tNot,
  func@(sub) = \(x : TType) -> \(y : TType) -> if isTInt x && isTInt y then tInt else tNot,
  func@(or)  = \(x : TType) -> \(y : TType) -> if isTBool x && isTBool y then tBool else tNot,
  func@(gt)  = \(x : TType) -> \(y : TType) -> if isTInt x && isTInt y then tBool else tNot,
  func@(eq)  = \(x : TType) -> \(y : TType) -> if isTInt x && isTInt y then tBool else tNot;
fdata Binary from BinaryOpAlg[B].B;
let apply2 (op : Binary) (x : Maybe) (y : Maybe) = (op.accept[{func : Maybe -> Maybe -> Maybe}] evalBinary).func x y;
let check2 (op : Binary) (x : TType) (y : TType) = (op.accept[{func : TType -> TType -> TType}] tcheckBinary).func x y;

sig UnaryOpAlg[U] where
  neg : U, not : U;
algebra evalUnary implements UnaryOpAlg[{func : Maybe -> Maybe}] where
  func@(neg) = \(x : Maybe) -> if isJust x then let x1 = fromJust x;
                                   if isInt x1 then just (intV (-getInt x1)) else nothing
                               else nothing,
  func@(not) = \(x : Maybe) -> if isJust x then let x1 = fromJust x;
                                   if isBool x1 then just (boolV (if getBool x1 then False else True)) else nothing
                               else nothing;
algebra tcheckUnary implements UnaryOpAlg[{func : TType -> TType}] where
  func@(neg) = \(x : TType) -> if isTInt x then tInt else tNot,
  func@(not) = \(x : TType) -> if isTBool x then tBool else tNot;
fdata Unary from UnaryOpAlg[U].U;
let apply1 (op : Unary) (x : Maybe) = (op.accept[{func : Maybe -> Maybe}] evalUnary).func x;
let check1 (op : Unary) (x : TType) = (op.accept[{func : TType -> TType}] tcheckUnary).func x;

sig ExpAlg[E] where
  literal : Value -> E,
  unary : Unary -> E -> E,
  binary : Binary -> E -> E -> E,
  ifbody : E -> E -> E -> E,
  var : String -> E,
  decl : String -> E -> E -> E;
type Env = { env : String -> Maybe };
let addToEnv (x : String) (y : Maybe) (z : Env) = { env = \(s : String) -> if x == s then y else z.env s };
algebra evalExp implements ExpAlg[{eval : Env -> Maybe}] where
  eval@(literal x) = \(e : Env) -> just x,
  eval@(unary op x) = \(e : Env) -> apply1 op (x.eval e),
  eval@(binary op x y) = \(e : Env) -> apply2 op (x.eval e) (y.eval e),
  eval@(var x) = \(e : Env) -> e.env x,
  eval@(decl x y z) = \(e : Env) -> z.eval (addToEnv x (y.eval e) e),
  eval@(ifbody x y z) = \(e : Env) -> if isJust (x.eval e) then let x1 = fromJust (x.eval e);
                                          if isBool x1 then let b = getBool x1; let y1 = y.eval e; let z1 = z.eval e;
                                              if sameTypeM y1 z1 then
                                                  if b then y.eval e else z.eval e
                                              else nothing
                                          else nothing
                                      else nothing;
type TEnv = { tEnv : String -> TType };
let addToTEnv (x : String) (y : TType) (z : TEnv) = { tEnv = \(s : String) -> if x == s then y else z.tEnv s };
algebra tcheckExp implements ExpAlg[{tcheck : TEnv -> TType}] where
  tcheck@(literal x) = \(t : TEnv) -> if isInt x then tInt else if isBool x then tBool else tNot,
  tcheck@(unary op x) = \(t : TEnv) -> check1 op (x.tcheck t),
  tcheck@(binary op x y) = \(t : TEnv) -> check2 op (x.tcheck t) (y.tcheck t),
  tcheck@(var x) = \(t : TEnv) -> t.tEnv x,
  tcheck@(decl x y z) = \(t : TEnv) -> z.tcheck (addToTEnv x (y.tcheck t) t),
  tcheck@(ifbody x y z) =  \(t : TEnv) -> if isTBool (x.tcheck t) then let y1 = y.tcheck t; let z1 = z.tcheck t;
                                             if sameTypeT y1 z1 then y1 else tNot
                                         else tNot;
fdata Exp from ExpAlg[E].E;
let evaluate (x : Exp) = showMaybe ((x.accept[{eval : Env -> Maybe}] evalExp).eval { env = \(s : String) -> nothing });
let typecheck (x : Exp) = showTType ((x.accept[{tcheck : TEnv -> TType}] tcheckExp).tcheck { tEnv = \(s : String) -> tNot });

let exp1 = decl "x" (literal (intV 3)) (decl "y" (literal (intV 4)) (ifbody (binary gt (var "x") (var "y")) (binary add (var "x") (literal (intV 1))) (binary add (var "y") (literal (intV 1)))));
let exp2 = decl "x" (literal (boolV True)) (decl "y" (literal (boolV False)) (binary or (unary not (binary or (unary not (var "x")) (var "y"))) (unary not (binary or (var "x") (unary not (var "y"))))));
"(\{evaluate exp1}, \{typecheck exp1}) || (\{evaluate exp2}, \{typecheck exp2})"

  
