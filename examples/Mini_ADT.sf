
-- Stuff about Maybe: Maybe should be defined as fdata Maybe?
data Maybe[A] = Just A | Nothing;
let isJust[A] (x : Maybe[A]) =
  case x of
      Just _  -> True
    | Nothing -> False;
let fromJust[A] (x : Maybe[A]) (y : A) =
  case x of
      Just z  -> z
    | Nothing -> y;

-- Values

sig ValueAlg[V] where
  intV  : Int -> V,
  boolV : Bool -> V;

fdata Value from ValueAlg[V].V;

-- Generated automatically?
type MatchV = { fromInt : Maybe[Int], fromBool : Maybe[Bool] };
algebra matchValue implements ValueAlg[MatchV] where
  fromInt@(intV x)   = Just[Int] x,
  fromInt@(boolV x)  = Nothing[Int],
  fromBool@(intV x)  = Nothing[Bool],
  fromBool@(boolV x) = Just[Bool] x;

-- Printing Values
type IPrint = { print : String };

algebra printValue implements ValueAlg[IPrint] where
  print@(intV x)  = "\{x}",
  print@(boolV x) = "\{x}";

-- Is this needed?
let isInt  (x : Value) = isJust[Int]    (x.accept[MatchV] matchValue).fromInt;
let isBool (x : Value) = isJust[Bool]   (x.accept[MatchV] matchValue).fromBool;
let toInt  (x : Value) = fromJust[Int]  (x.accept[MatchV] matchValue).fromInt 0;
let toBool (x : Value) = fromJust[Bool] (x.accept[MatchV] matchValue).fromBool False;
let printV (x : Value) = (x.accept[IPrint] printValue).print;

-- this one stills needs to be written by hand
let sameTypeV (x : Value) (y : Value) = (isInt x && isInt y) || (isBool x && isBool y);

-- Types

sig TypAlg[T] where
  tInt  : T,
  tBool : T;

fdata Typ from TypAlg[T].T;

-- Generated using Maybe?
type MatchT = { isTInt : Bool, isTBool : Bool };
algebra matchTyp implements TypAlg[MatchT] where
  isTInt@(tInt)   = True,
  isTInt@(tBool)  = False,
  isTBool@(tInt)  = False,
  isTBool@(tBool) = True;

-- Printing types
algebra printTyp implements TypAlg[IPrint] where
  print@(tInt)  = "TInt",
  print@(tBool) = "TBool";

-- do we need this?
let isTInt  (x : Typ) = (x.accept[MatchT] matchTyp).isTInt;
let isTBool (x : Typ) = (x.accept[MatchT] matchTyp).isTBool;
let eqT (x : Typ) (y : Typ) = (isTInt x && isTInt y) || (isTBool x && isTBool y);
let printT (x : Typ) = (x.accept[IPrint] printTyp).print;

let toValue (x : Maybe[Value]) = fromJust[Value] x (intV 0);
let toTyp   (x : Maybe[Typ])   = fromJust[Typ] x tInt;
let sameTypeM (x : Maybe[Value]) (y : Maybe[Value]) = isJust[Value] x && isJust[Value] y && sameTypeV (toValue x) (toValue y);
let eqM (x : Maybe[Typ]) (y : Maybe[Typ]) = isJust[Typ] x && isJust[Typ] y && eqT (toTyp x) (toTyp y);
let printMV (x : Maybe[Value]) = if isJust[Value] x then printV (toValue x) else "NoValue";
let printMT (x : Maybe[Typ])   = if isJust[Typ]   x then printT (toTyp x)   else "NoType";

-- Binary operations
sig BinaryAlg[B] where
 add : B, sub : B, gt : B, eq : B, ane : B, or : B;

-- evaluation and type-checking of binary operations: this approach will not work if we want extensible types and values

type EvalB   = { eval   : Maybe[Value] -> Maybe[Value] -> Maybe[Value] };
type TcheckB = { tcheck : Maybe[Typ]   -> Maybe[Typ]   -> Maybe[Typ]   };

-- Problem 1: We need something similar to pattern matching notation for Values?
-- Solution: we need to support a notation similar to pattern matching for fdata.

-- Problem 2: evalBinary assumes that Values are not extensible (example we cannot add String values 
-- later on). How to deal with extensible values.
-- Solution: We need to use algebra transformations if we want the definition to be extensible.

{-
type EvalB[V]   = { eval   : Maybe[V] -> Maybe[V] -> Maybe[V] };

let evalBinary [V] (alg : ValueAlg[V]) : BinaryAlg[V] = { 
  add = \x. \y. {eval = alg.intV }

let evalBinaryExt [V] (alg : ExtenValueAlg[V]) : ExtendedBinaryAlg[V] = {... alg.string()}
-}

-- Algebras should take parameters, probably: algebra evalBinary V (alg : ValueAlg[V], n : int) implements BinaryAlg[EvalB[V]]

algebra evalBinary implements BinaryAlg[EvalB] where
  eval@(add) = \(x : Maybe[Value]) -> \(y : Maybe[Value]) -> 
--                 case (x,y) of 
--                    | (Just (IntV v1), Just (IntV v2)) -> Just (IntV (v1 + v2))
--                    | _ -> Nothing 
               let x1 = toValue x; let y1 = toValue y;
               if isJust[Value] x && isJust[Value] y && isInt x1 && isInt y1 then Just[Value] (intV (toInt x1 + toInt y1)) else Nothing[Value],
  eval@(sub) = \(x : Maybe[Value]) -> \(y : Maybe[Value]) -> let x1 = toValue x; let y1 = toValue y;
               if isJust[Value] x && isJust[Value] y && isInt x1 && isInt y1 then Just[Value] (intV (toInt x1 - toInt y1)) else Nothing[Value],
  eval@(gt)  = \(x : Maybe[Value]) -> \(y : Maybe[Value]) -> let x1 = toValue x; let y1 = toValue y;
               if isJust[Value] x && isJust[Value] y && isInt x1 && isInt y1 then Just[Value] (boolV (toInt x1 > toInt y1)) else Nothing[Value],
  eval@(eq)  = \(x : Maybe[Value]) -> \(y : Maybe[Value]) -> let x1 = toValue x; let y1 = toValue y;
               if isJust[Value] x && isJust[Value] y && isInt x1 && isInt y1 then Just[Value] (boolV (toInt x1 == toInt y1)) else Nothing[Value],
  eval@(ane) = \(x : Maybe[Value]) -> \(y : Maybe[Value]) -> let x1 = toValue x; let y1 = toValue y;
               if isJust[Value] x && isJust[Value] y && isBool x1 && isBool y1 then Just[Value] (boolV (toBool x1 && toBool y1)) else Nothing[Value],
  eval@(or)  = \(x : Maybe[Value]) -> \(y : Maybe[Value]) -> let x1 = toValue x; let y1 = toValue y;
               if isJust[Value] x && isJust[Value] y && isBool x1 && isBool y1 then Just[Value] (boolV (toBool x1 || toBool y1)) else Nothing[Value];
algebra tcheckBinary implements BinaryAlg[TcheckB] where
  tcheck@(add) = \(x : Maybe[Typ]) -> \(y : Maybe[Typ]) -> let x1 = toTyp x; let y1 = toTyp y;
               if isJust[Typ] x && isJust[Typ] y && isTInt x1 && isTInt y1 then Just[Typ] tInt else Nothing[Typ],
  tcheck@(sub) = \(x : Maybe[Typ]) -> \(y : Maybe[Typ]) -> let x1 = toTyp x; let y1 = toTyp y;
               if isJust[Typ] x && isJust[Typ] y && isTInt x1 && isTInt y1 then Just[Typ] tInt else Nothing[Typ],
  tcheck@(gt)  = \(x : Maybe[Typ]) -> \(y : Maybe[Typ]) -> let x1 = toTyp x; let y1 = toTyp y;
               if isJust[Typ] x && isJust[Typ] y && isTInt x1 && isTInt y1 then Just[Typ] tBool else Nothing[Typ],
  tcheck@(eq)  = \(x : Maybe[Typ]) -> \(y : Maybe[Typ]) -> let x1 = toTyp x; let y1 = toTyp y;
               if isJust[Typ] x && isJust[Typ] y && isTInt x1 && isTInt y1 then Just[Typ] tBool else Nothing[Typ],
  tcheck@(ane) = \(x : Maybe[Typ]) -> \(y : Maybe[Typ]) -> let x1 = toTyp x; let y1 = toTyp y;
               if isJust[Typ] x && isJust[Typ] y && isTBool x1 && isTBool y1 then Just[Typ] tBool else Nothing[Typ],
  tcheck@(or)  = \(x : Maybe[Typ]) -> \(y : Maybe[Typ]) -> let x1 = toTyp x; let y1 = toTyp y;
               if isJust[Typ] x && isJust[Typ] y && isTBool x1 && isTBool y1 then Just[Typ] tBool else Nothing[Typ];
algebra printBinary implements BinaryAlg[IPrint] where
  print@(add) = "+",
  print@(sub) = "-",
  print@(gt)  = ">",
  print@(eq)  = "==",
  print@(ane) = "&&",
  print@(or)  = "||";
fdata Binary from BinaryAlg[B].B;

-- We should not be writing the following auxiliary functions by hand
let apply2E (op : Binary) (x : Maybe[Value]) (y : Maybe[Value]) = (op.accept[EvalB]   evalBinary  ).eval   x y;
let apply2T (op : Binary) (x : Maybe[Typ])   (y : Maybe[Typ])   = (op.accept[TcheckB] tcheckBinary).tcheck x y;
let print2 (op : Binary) = (op.accept[IPrint] printBinary).print;

sig UnaryAlg[U] where
  neg : U, not : U;
type EvalU   = { eval   : Maybe[Value] -> Maybe[Value] };
type TcheckU = { tcheck : Maybe[Typ]   -> Maybe[Typ]   };
algebra evalUnary implements UnaryAlg[EvalU] where
  eval@(neg) = \(x : Maybe[Value]) -> let x1 = toValue x;
               if isJust[Value] x && isInt x1 then Just[Value] (intV (-toInt x1)) else Nothing[Value],
  eval@(not) = \(x : Maybe[Value]) -> let x1 = toValue x;
               if isJust[Value] x && isBool x1 then Just[Value] (boolV (if toBool x1 then False else True)) else Nothing[Value];
algebra tcheckUnary implements UnaryAlg[TcheckU] where
  tcheck@(neg) = \(x : Maybe[Typ]) -> let x1 = toTyp x;
                 if isJust[Typ] x && isTInt x1 then Just[Typ] tInt else Nothing[Typ],
  tcheck@(not) = \(x : Maybe[Typ]) -> let x1 = toTyp x;
                 if isJust[Typ] x && isTBool x1 then Just[Typ] tBool else Nothing[Typ];
algebra printUnary implements UnaryAlg[IPrint] where
  print@(neg) = "-",
  print@(not) = "!";
fdata Unary from UnaryAlg[U].U;
let apply1E (op : Unary) (x : Maybe[Value]) = (op.accept[EvalU]   evalUnary  ).eval   x;
let apply1T (op : Unary) (x : Maybe[Typ])   = (op.accept[TcheckU] tcheckUnary).tcheck x;
let print1 (op : Unary) = (op.accept[IPrint] printUnary).print;

type Env  = { env  : String -> Maybe[Value] };
type TEnv = { tenv : String -> Maybe[Typ]   };
let addToEnv  (x : String) (y : Maybe[Value]) (z : Env)  = { env  = \(s : String) -> if x == s then y else z.env  s };
let addToTEnv (x : String) (y : Maybe[Typ])   (z : TEnv) = { tenv = \(s : String) -> if x == s then y else z.tenv s };

sig ExpAlg[E] where
  literal : Value -> E,
  unary   : Unary -> E -> E,
  binary  : Binary -> E -> E -> E,
  ifbody  : E -> E -> E -> E,
  var     : String -> E,
  decl    : String -> E -> E -> E;
type EvalE   = { eval   : Env  -> Maybe[Value] };
type TcheckE = { tcheck : TEnv -> Maybe[Typ]   };
algebra evalExp implements ExpAlg[EvalE] where
  eval@(literal x)     = \(e : Env) -> Just[Value] x,
  eval@(unary op x)    = \(e : Env) -> apply1E op (x.eval e),
  eval@(binary op x y) = \(e : Env) -> apply2E op (x.eval e) (y.eval e),
  eval@(var x)         = \(e : Env) -> e.env x,
  eval@(decl x y z)    = \(e : Env) -> z.eval (addToEnv x (y.eval e) e),
  eval@(ifbody x y z)  = \(e : Env) -> let x1 = x.eval e; let y1 = y.eval e; let z1 = z.eval e;
                         if isJust[Value] x1 && isBool (toValue x1) && sameTypeM y1 z1
                         then if toBool (toValue x1) then y1 else z1
                         else Nothing[Value];
algebra tcheckExp implements ExpAlg[TcheckE] where
  tcheck@(literal x)     = \(t : TEnv) -> if isInt x then Just[Typ] tInt else if isBool x then Just[Typ] tBool else Nothing[Typ],
  tcheck@(unary op x)    = \(t : TEnv) -> apply1T op (x.tcheck t),
  tcheck@(binary op x y) = \(t : TEnv) -> apply2T op (x.tcheck t) (y.tcheck t),
  tcheck@(var x)         = \(t : TEnv) -> t.tenv x,
  tcheck@(decl x y z)    = \(t : TEnv) -> z.tcheck (addToTEnv x (y.tcheck t) t),
  tcheck@(ifbody x y z)  = \(t : TEnv) -> let x1 = x.tcheck t; let y1 = y.tcheck t; let z1 = z.tcheck t;
                                          if isJust[Typ] x1 && isTBool (toTyp x1) && eqM y1 z1 then y1 else Nothing[Typ];


-- Code for simple pretty printer looks good!
-- However, lets suppose we wanted to make the pretty printer prettier by using extra parameters (for indentation, etc...). 

algebra printExp implements ExpAlg[IPrint] where
  print@(literal x)     = printV x,
  print@(unary op x)    = "\{print1 op}(\{x.print})",
  print@(binary op x y) = "(\{x.print}) \{print2 op} (\{y.print})",
  print@(var x)         = "\{x}",
  print@(decl x y z)    = "var \{x} = \{y.print}; \{z.print}",
  print@(ifbody x y z)  = "if (\{x.print}) \{y.print}; else \{z.print}";
fdata Exp from ExpAlg[E].E;

let exp1 = decl "x" (literal (intV 3)) (decl "y" (literal (intV 4)) (ifbody (binary gt (var "x") (var "y")) (binary add (var "x") (literal (intV 1))) (binary add (var "y") (literal (intV 1)))));

#let res = exp1.accept[EvalE & TcheckE & IPrint]<evalExp, tcheckExp, printExp>;
# Doesn't work. f2j: Pattern match failure in do expression at lib/BaseTransCFJava.hs:468:16-42

let res1 = (exp1.accept[EvalE] evalExp).eval { env = \(s : String) -> Nothing[Value] };
let res2 = (exp1.accept[TcheckE] tcheckExp).tcheck { tenv = \(s : String) -> Nothing[Typ] };
let res3 = (exp1.accept[IPrint] printExp).print;

"\{printMV res1} || \{printMT res2} || \{res3}"
# 5 || TInt || var x = 3; var y = 4; if ((x) > (y)) (x) + (1); else (y) + (1)

# TODO:
# (1) Constructors: LOWER_IDENT => UPPER_IDENT (how?);
# (2) Syntactic sugar: x.accept[A & B]<algA, algB> => x<algA, algB>.

